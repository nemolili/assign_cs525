cscope 15 $HOME/development/Assignment/assign3               0000044175
	@buffer_mgr.h

1 #iâdeà
BUFFER_MANAGER_H


2 
	#BUFFER_MANAGER_H


	)

5 
	~"db”rÜ.h
"

8 
	~"dt.h
"

11 
	eR•Ïûm’tSŒ©egy
 {

12 
	mRS_FIFO
 = 0,

13 
	mRS_LRU
 = 1,

14 
	mRS_CLOCK
 = 2,

15 
	mRS_LFU
 = 3,

16 
	mRS_LRU_K
 = 4

17 } 
	tR•Ïûm’tSŒ©egy
;

20 
	tPageNumb”
;

21 
	#NO_PAGE
 -1

	)

23 
	sBM_BufãrPoŞ
 {

24 *
	m·geFe
;

25 
	mnumPages
;

26 
R•Ïûm’tSŒ©egy
 
	m¡¿‹gy
;

27 *
	mmgmtD©a
;

29 } 
	tBM_BufãrPoŞ
;

31 
	sBM_PageHªdË
 {

32 
PageNumb”
 
	m·geNum
;

33 *
	md©a
;

34 } 
	tBM_PageHªdË
;

37 
	#MAKE_POOL
() \

38 ((
BM_BufãrPoŞ
 *è
	`m®loc
 ((BM_BufãrPoŞ)))

	)

40 
	#MAKE_PAGE_HANDLE
() \

41 ((
BM_PageHªdË
 *è
	`m®loc
 ((BM_PageHªdË)))

	)

44 
RC
 
š™BufãrPoŞ
(
BM_BufãrPoŞ
 *cÚ¡ 
bm
, cÚ¡ *cÚ¡ 
·geFeName
,

45 cÚ¡ 
numPages
, 
R•Ïûm’tSŒ©egy
 
¡¿‹gy
,

46 *
¡¿tD©a
);

47 
RC
 
shutdownBufãrPoŞ
(
BM_BufãrPoŞ
 *cÚ¡ 
bm
);

48 
RC
 
fÜûFlushPoŞ
(
BM_BufãrPoŞ
 *cÚ¡ 
bm
);

51 
RC
 
m¬kDœty
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
, 
BM_PageHªdË
 *cÚ¡ 
·ge
);

52 
RC
 
uÅšPage
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
, 
BM_PageHªdË
 *cÚ¡ 
·ge
);

53 
RC
 
fÜûPage
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
, 
BM_PageHªdË
 *cÚ¡ 
·ge
);

54 
RC
 
pšPage
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
, 
BM_PageHªdË
 *cÚ¡ 
·ge
,

55 cÚ¡ 
PageNumb”
 
·geNum
);

58 
PageNumb”
 *
g‘F¿meCÚ‹Ás
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
);

59 
boŞ
 *
g‘DœtyFÏgs
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
);

60 *
g‘FixCouÁs
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
);

61 
g‘NumR—dIO
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
);

62 
g‘NumWr™eIO
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
);

	@buffer_mgr_stat.c

1 
	~"bufãr_mgr_¡©.h
"

2 
	~"bufãr_mgr.h
"

4 
	~<¡dio.h
>

5 
	~<¡dlib.h
>

8 
´štSŒ©
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
);

12 
	$´štPoŞCÚ‹Á
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
)

14 
PageNumb”
 *
äameCÚ‹Á
;

15 
boŞ
 *
dœty
;

16 *
fixCouÁ
;

17 
i
;

19 
äameCÚ‹Á
 = 
	`g‘F¿meCÚ‹Ás
(
bm
);

20 
dœty
 = 
	`g‘DœtyFÏgs
(
bm
);

21 
fixCouÁ
 = 
	`g‘FixCouÁs
(
bm
);

23 
	`´štf
("{");

24 
	`´štSŒ©
(
bm
);

25 
	`´štf
(" %i}: ", 
bm
->
numPages
);

27 
i
 = 0; i < 
bm
->
numPages
; i++)

28 
	`´štf
("%s[%i%s%i]", ((
i
 =ğ0è? "" : ","è, 
äameCÚ‹Á
[i], (
dœty
[i] ? "x": " "), 
fixCouÁ
[i]);

29 
	`´štf
("\n");

30 
	}
}

33 
	$¥rštPoŞCÚ‹Á
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
)

35 
PageNumb”
 *
äameCÚ‹Á
;

36 
boŞ
 *
dœty
;

37 *
fixCouÁ
;

38 
i
;

39 *
mes§ge
;

40 
pos
 = 0;

42 
mes§ge
 = (*è
	`m®loc
(256 + (22 * 
bm
->
numPages
));

43 
äameCÚ‹Á
 = 
	`g‘F¿meCÚ‹Ás
(
bm
);

44 
dœty
 = 
	`g‘DœtyFÏgs
(
bm
);

45 
fixCouÁ
 = 
	`g‘FixCouÁs
(
bm
);

47 
i
 = 0; i < 
bm
->
numPages
; i++)

48 
pos
 +ğ
	`¥rštf
(
mes§ge
 +…os, "%s[%i%s%i]", ((
i
 =ğ0è? "" : ","è, 
äameCÚ‹Á
[i], (
dœty
[i] ? "x": " "), 
fixCouÁ
[i]);

50  
mes§ge
;

51 
	}
}

55 
	$´štPageCÚ‹Á
 (
BM_PageHªdË
 *cÚ¡ 
·ge
)

57 
i
;

59 
	`´štf
("[Pag%i]\n", 
·ge
->
·geNum
);

61 
i
 = 1; i <ğ
PAGE_SIZE
; i++)

62 
	`´štf
("%02X%s%s", 
·ge
->
d©a
[
i
], (i % 8) ? "" : " ", (i % 64) ? "" : "\n");

63 
	}
}

66 
	$¥rštPageCÚ‹Á
 (
BM_PageHªdË
 *cÚ¡ 
·ge
)

68 
i
;

69 *
mes§ge
;

70 
pos
 = 0;

72 
mes§ge
 = (*è
	`m®loc
(30 + (2 * 
PAGE_SIZE
) + (PAGE_SIZE % 64) + (PAGE_SIZE % 8));

73 
pos
 +ğ
	`¥rštf
(
mes§ge
 +…os, "[Pag%i]\n", 
·ge
->
·geNum
);

75 
i
 = 1; i <ğ
PAGE_SIZE
; i++)

76 
pos
 +ğ
	`¥rštf
(
mes§ge
 +…os, "%02X%s%s", 
·ge
->
d©a
[
i
], (i % 8) ? "" : " ", (i % 64) ? "" : "\n");

78  
mes§ge
;

79 
	}
}

82 
	$´štSŒ©
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
)

84 
bm
->
¡¿‹gy
)

86 
RS_FIFO
:

87 
	`´štf
("FIFO");

89 
RS_LRU
:

90 
	`´štf
("LRU");

92 
RS_CLOCK
:

93 
	`´štf
("CLOCK");

95 
RS_LFU
:

96 
	`´štf
("LFU");

98 
RS_LRU_K
:

99 
	`´štf
("LRU-K");

102 
	`´štf
("%i", 
bm
->
¡¿‹gy
);

105 
	}
}

	@buffer_mgr_stat.h

1 #iâdeà
BUFFER_MGR_STAT_H


2 
	#BUFFER_MGR_STAT_H


	)

4 
	~"bufãr_mgr.h
"

7 
´štPoŞCÚ‹Á
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
);

8 
´štPageCÚ‹Á
 (
BM_PageHªdË
 *cÚ¡ 
·ge
);

9 *
¥rštPoŞCÚ‹Á
 (
BM_BufãrPoŞ
 *cÚ¡ 
bm
);

10 *
¥rštPageCÚ‹Á
 (
BM_PageHªdË
 *cÚ¡ 
·ge
);

	@dberror.c

1 
	~"db”rÜ.h
"

3 
	~<¡ršg.h
>

4 
	~<¡dlib.h
>

5 
	~<¡dio.h
>

7 *
	gRC_mes§ge
;

11 
	$´štE¼Ü
 (
RC
 
”rÜ
)

13 ià(
RC_mes§ge
 !ğ
NULL
)

14 
	`´štf
("EC (%i), \"%s\"\n", 
”rÜ
, 
RC_mes§ge
);

16 
	`´štf
("EC (%i)\n", 
”rÜ
);

17 
	}
}

20 
	$”rÜMes§ge
 (
RC
 
”rÜ
)

22 *
mes§ge
;

24 ià(
RC_mes§ge
 !ğ
NULL
)

26 
mes§ge
 = (*è
	`m®loc
(
	`¡¾’
(
RC_mes§ge
) + 30);

27 
	`¥rštf
(
mes§ge
, "EC (%i), \"%s\"\n", 
”rÜ
, 
RC_mes§ge
);

31 
mes§ge
 = (*è
	`m®loc
(30);

32 
	`¥rštf
(
mes§ge
, "EC (%i)\n", 
”rÜ
);

35  
mes§ge
;

36 
	}
}

	@dberror.h

1 #iâdeà
DBERROR_H


2 
	#DBERROR_H


	)

4 
	~"¡dio.h
"

7 
	#PAGE_SIZE
 4096

	)

10 
	tRC
;

12 
	#RC_OK
 0

	)

13 
	#RC_FILE_NOT_FOUND
 1

	)

14 
	#RC_FILE_HANDLE_NOT_INIT
 2

	)

15 
	#RC_WRITE_FAILED
 3

	)

16 
	#RC_READ_NON_EXISTING_PAGE
 4

	)

18 
	#RC_RM_COMPARE_VALUE_OF_DIFFERENT_DATATYPE
 200

	)

19 
	#RC_RM_EXPR_RESULT_IS_NOT_BOOLEAN
 201

	)

20 
	#RC_RM_BOOLEAN_EXPR_ARG_IS_NOT_BOOLEAN
 202

	)

21 
	#RC_RM_NO_MORE_TUPLES
 203

	)

22 
	#RC_RM_NO_PRINT_FOR_DATATYPE
 204

	)

23 
	#RC_RM_UNKOWN_DATATYPE
 205

	)

25 
	#RC_IM_KEY_NOT_FOUND
 300

	)

26 
	#RC_IM_KEY_ALREADY_EXISTS
 301

	)

27 
	#RC_IM_N_TO_LAGE
 302

	)

28 
	#RC_IM_NO_MORE_ENTRIES
 303

	)

31 *
RC_mes§ge
;

34 
´štE¼Ü
 (
RC
 
”rÜ
);

35 *
”rÜMes§ge
 (
RC
 
”rÜ
);

37 
	#THROW
(
rc
,
mes§ge
) \

39 
RC_mes§ge
=
mes§ge
; \

40  
rc
; \

42 

	)

44 
	#CHECK
(
code
) \

46 
rc_š‹º®
 = (
code
); \

47 ià(
rc_š‹º®
 !ğ
RC_OK
) \

49 *
mes§ge
 = 
	`”rÜMes§ge
(
rc_š‹º®
); \

50 
	`´štf
("[%s-L%i-%s] ERROR: O³¿tiÚ„‘uºedƒ¼Ü: %s\n",
__FILE__
, 
__LINE__
, 
__TIME__
, 
mes§ge
); \

51 
	`ä“
(
mes§ge
); \

52 
	`ex™
(1); \

54 } 0);

	)

	@dt.h

1 #iâdeà
DT_H


2 
	#DT_H


	)

5 #iâdeà
boŞ


6 
	tboŞ
;

7 
	#Œue
 1

	)

8 
	#çl£
 0

	)

11 
	#TRUE
 
Œue


	)

12 
	#FALSE
 
çl£


	)

	@expr.c

1 
	~<¡ršg.h
>

2 
	~<¡dlib.h
>

4 
	~"db”rÜ.h
"

5 
	~"»cÜd_mgr.h
"

6 
	~"ex´.h
"

7 
	~"bËs.h
"

10 
RC


11 
	$v®ueEqu®s
 (
V®ue
 *
Ëá
, V®u*
right
, V®u*
»suÉ
)

13 if(
Ëá
->
dt
 !ğ
right
->dt)

14 
	`THROW
(
RC_RM_COMPARE_VALUE_OF_DIFFERENT_DATATYPE
, "equality comparison only supported for values ofhe same datatype");

16 
»suÉ
->
dt
 = 
DT_BOOL
;

18 
Ëá
->
dt
) {

19 
DT_INT
:

20 
»suÉ
->
v
.
boŞV
 = (
Ëá
->v.
štV
 =ğ
right
->v.intV);

22 
DT_FLOAT
:

23 
»suÉ
->
v
.
boŞV
 = (
Ëá
->v.
æßtV
 =ğ
right
->v.floatV);

25 
DT_BOOL
:

26 
»suÉ
->
v
.
boŞV
 = (
Ëá
->v.boŞV =ğ
right
->v.boolV);

28 
DT_STRING
:

29 
»suÉ
->
v
.
boŞV
 = (
	`¡rcmp
(
Ëá
->v.
¡ršgV
, 
right
->v.stringV) == 0);

33  
RC_OK
;

34 
	}
}

36 
RC


37 
	$v®ueSm®Ër
 (
V®ue
 *
Ëá
, V®u*
right
, V®u*
»suÉ
)

39 if(
Ëá
->
dt
 !ğ
right
->dt)

40 
	`THROW
(
RC_RM_COMPARE_VALUE_OF_DIFFERENT_DATATYPE
, "equality comparison only supported for values ofhe same datatype");

42 
»suÉ
->
dt
 = 
DT_BOOL
;

44 
Ëá
->
dt
) {

45 
DT_INT
:

46 
»suÉ
->
v
.
boŞV
 = (
Ëá
->v.
štV
 < 
right
->v.intV);

48 
DT_FLOAT
:

49 
»suÉ
->
v
.
boŞV
 = (
Ëá
->v.
æßtV
 < 
right
->v.floatV);

51 
DT_BOOL
:

52 
»suÉ
->
v
.
boŞV
 = (
Ëá
->v.boŞV < 
right
->v.boolV);

53 
DT_STRING
:

54 
»suÉ
->
v
.
boŞV
 = (
	`¡rcmp
(
Ëá
->v.
¡ršgV
, 
right
->v.stringV) < 0);

58  
RC_OK
;

59 
	}
}

61 
RC


62 
	$boŞNÙ
 (
V®ue
 *
šput
, V®u*
»suÉ
)

64 ià(
šput
->
dt
 !ğ
DT_BOOL
)

65 
	`THROW
(
RC_RM_BOOLEAN_EXPR_ARG_IS_NOT_BOOLEAN
, "boolean NOT„equires boolean input");

66 
»suÉ
->
dt
 = 
DT_BOOL
;

67 
»suÉ
->
v
.
boŞV
 = !(
šput
->v.boolV);

69  
RC_OK
;

70 
	}
}

72 
RC


73 
	$boŞAnd
 (
V®ue
 *
Ëá
, V®u*
right
, V®u*
»suÉ
)

75 ià(
Ëá
->
dt
 !ğ
DT_BOOL
 || 
right
->dt != DT_BOOL)

76 
	`THROW
(
RC_RM_BOOLEAN_EXPR_ARG_IS_NOT_BOOLEAN
, "boolean AND„equires boolean inputs");

77 
»suÉ
->
v
.
boŞV
 = (
Ëá
->v.boŞV && 
right
->v.boolV);

79  
RC_OK
;

80 
	}
}

82 
RC


83 
	$boŞOr
 (
V®ue
 *
Ëá
, V®u*
right
, V®u*
»suÉ
)

85 ià(
Ëá
->
dt
 !ğ
DT_BOOL
 || 
right
->dt != DT_BOOL)

86 
	`THROW
(
RC_RM_BOOLEAN_EXPR_ARG_IS_NOT_BOOLEAN
, "boolean OR„equires boolean inputs");

87 
»suÉ
->
v
.
boŞV
 = (
Ëá
->v.boŞV || 
right
->v.boolV);

89  
RC_OK
;

90 
	}
}

92 
RC


93 
	$ev®Ex´
 (
RecÜd
 *
»cÜd
, 
Schema
 *
schema
, 
Ex´
 *
ex´
, 
V®ue
 **
»suÉ
)

95 
V®ue
 *
lIn
;

96 
V®ue
 *
rIn
;

97 
	`MAKE_VALUE
(*
»suÉ
, 
DT_INT
, -1);

99 
ex´
->
ty³
)

101 
EXPR_OP
:

103 
O³¿tÜ
 *
İ
 = 
ex´
->expr.op;

104 
boŞ
 
twoArgs
 = (
İ
->
ty³
 !ğ
OP_BOOL_NOT
);

108 
	`CHECK
(
	`ev®Ex´
(
»cÜd
, 
schema
, 
İ
->
¬gs
[0], &
lIn
));

109 ià(
twoArgs
)

110 
	`CHECK
(
	`ev®Ex´
(
»cÜd
, 
schema
, 
İ
->
¬gs
[1], &
rIn
));

112 
İ
->
ty³
)

114 
OP_BOOL_NOT
:

115 
	`CHECK
(
	`boŞNÙ
(
lIn
, *
»suÉ
));

117 
OP_BOOL_AND
:

118 
	`CHECK
(
	`boŞAnd
(
lIn
, 
rIn
, *
»suÉ
));

120 
OP_BOOL_OR
:

121 
	`CHECK
(
	`boŞOr
(
lIn
, 
rIn
, *
»suÉ
));

123 
OP_COMP_EQUAL
:

124 
	`CHECK
(
	`v®ueEqu®s
(
lIn
, 
rIn
, *
»suÉ
));

126 
OP_COMP_SMALLER
:

127 
	`CHECK
(
	`v®ueSm®Ër
(
lIn
, 
rIn
, *
»suÉ
));

134 
	`ä“V®
(
lIn
);

135 ià(
twoArgs
)

136 
	`ä“V®
(
rIn
);

139 
EXPR_CONST
:

140 
	`CPVAL
(*
»suÉ
,
ex´
->ex´.
cÚs
);

142 
EXPR_ATTRREF
:

143 
	`ä“
(*
»suÉ
);

144 
	`CHECK
(
	`g‘A‰r
(
»cÜd
, 
schema
, 
ex´
->ex´.
©ŒRef
, 
»suÉ
));

148  
RC_OK
;

149 
	}
}

151 
RC


152 
	$ä“Ex´
 (
Ex´
 *
ex´
)

154 
ex´
->
ty³
)

156 
EXPR_OP
:

158 
O³¿tÜ
 *
İ
 = 
ex´
->expr.op;

159 
İ
->
ty³
)

161 
OP_BOOL_NOT
:

162 
	`ä“Ex´
(
İ
->
¬gs
[0]);

165 
	`ä“Ex´
(
İ
->
¬gs
[0]);

166 
	`ä“Ex´
(
İ
->
¬gs
[1]);

169 
	`ä“
(
İ
->
¬gs
);

172 
EXPR_CONST
:

173 
	`ä“V®
(
ex´
->ex´.
cÚs
);

175 
EXPR_ATTRREF
:

178 
	`ä“
(
ex´
);

180  
RC_OK
;

181 
	}
}

184 
	$ä“V®
 (
V®ue
 *
v®
)

186 ià(
v®
->
dt
 =ğ
DT_STRING
)

187 
	`ä“
(
v®
->
v
.
¡ršgV
);

188 
	`ä“
(
v®
);

189 
	}
}

	@expr.h

1 #iâdeà
EXPR_H


2 
	#EXPR_H


	)

4 
	~"db”rÜ.h
"

5 
	~"bËs.h
"

8 
	eEx´Ty³
 {

9 
	mEXPR_OP
,

10 
	mEXPR_CONST
,

11 
	mEXPR_ATTRREF


12 } 
	tEx´Ty³
;

14 
	sEx´
 {

15 
Ex´Ty³
 
	mty³
;

16 
	uex´
 {

17 
V®ue
 *
	mcÚs
;

18 
	m©ŒRef
;

19 
O³¿tÜ
 *
	mİ
;

20 } 
	mex´
;

21 } 
	tEx´
;

24 
	eOpTy³
 {

25 
	mOP_BOOL_AND
,

26 
	mOP_BOOL_OR
,

27 
	mOP_BOOL_NOT
,

28 
	mOP_COMP_EQUAL
,

29 
	mOP_COMP_SMALLER


30 } 
	tOpTy³
;

32 
	sO³¿tÜ
 {

33 
OpTy³
 
	mty³
;

34 
Ex´
 **
	m¬gs
;

35 } 
	tO³¿tÜ
;

38 
RC
 
v®ueEqu®s
 (
V®ue
 *
Ëá
, V®u*
right
, V®u*
»suÉ
);

39 
RC
 
v®ueSm®Ër
 (
V®ue
 *
Ëá
, V®u*
right
, V®u*
»suÉ
);

40 
RC
 
boŞNÙ
 (
V®ue
 *
šput
, V®u*
»suÉ
);

41 
RC
 
boŞAnd
 (
V®ue
 *
Ëá
, V®u*
right
, V®u*
»suÉ
);

42 
RC
 
boŞOr
 (
V®ue
 *
Ëá
, V®u*
right
, V®u*
»suÉ
);

43 
RC
 
ev®Ex´
 (
RecÜd
 *
»cÜd
, 
Schema
 *
schema
, 
Ex´
 *
ex´
, 
V®ue
 **
»suÉ
);

44 
RC
 
ä“Ex´
 (
Ex´
 *
ex´
);

45 
ä“V®
(
V®ue
 *
v®
);

48 
	#CPVAL
(
_»suÉ
,
_šput
) \

50 (
_»suÉ
)->
dt
 = 
_šput
->dt; \

51 
_šput
->
dt
) \

53 
DT_INT
: \

54 (
_»suÉ
)->
v
.
štV
 = 
_šput
->v.intV; \

56 
DT_STRING
: \

57 (
_»suÉ
)->
v
.
¡ršgV
 = (*è
	`m®loc
(
	`¡¾’
(
_šput
->v.stringV)); \

58 
	`¡rıy
((
_»suÉ
)->
v
.
¡ršgV
, 
_šput
->v.stringV); \

60 
DT_FLOAT
: \

61 (
_»suÉ
)->
v
.
æßtV
 = 
_šput
->v.floatV; \

63 
DT_BOOL
: \

64 (
_»suÉ
)->
v
.
boŞV
 = 
_šput
->v.boolV; \

67 } 0)

	)

69 
	#MAKE_BINOP_EXPR
(
_»suÉ
,
_Ëá
,
_right
,
_İty³
) \

71 
O³¿tÜ
 *
_İ
 = (O³¿tÜ *è
	`m®loc
((Operator)); \

72 
_»suÉ
 = (
Ex´
 *è
	`m®loc
((Expr)); \

73 
_»suÉ
->
ty³
 = 
EXPR_OP
; \

74 
_»suÉ
->
ex´
.
İ
 = 
_İ
; \

75 
_İ
->
ty³
 = 
_İty³
; \

76 
_İ
->
¬gs
 = (
Ex´
 **è
	`m®loc
(2 * (Expr*)); \

77 
_İ
->
¬gs
[0] = 
_Ëá
; \

78 
_İ
->
¬gs
[1] = 
_right
; \

79 } 0)

	)

81 
	#MAKE_UNOP_EXPR
(
_»suÉ
,
_šput
,
_İty³
) \

83 
O³¿tÜ
 *
_İ
 = (O³¿tÜ *è
	`m®loc
((Operator)); \

84 
_»suÉ
 = (
Ex´
 *è
	`m®loc
((Expr)); \

85 
_»suÉ
->
ty³
 = 
EXPR_OP
; \

86 
_»suÉ
->
ex´
.
İ
 = 
_İ
; \

87 
_İ
->
ty³
 = 
_İty³
; \

88 
_İ
->
¬gs
 = (
Ex´
 **è
	`m®loc
((Expr*)); \

89 
_İ
->
¬gs
[0] = 
_šput
; \

90 } 0)

	)

92 
	#MAKE_ATTRREF
(
_»suÉ
,
_©Œ
) \

94 
_»suÉ
 = (
Ex´
 *è
	`m®loc
((Expr)); \

95 
_»suÉ
->
ty³
 = 
EXPR_ATTRREF
; \

96 
_»suÉ
->
ex´
.
©ŒRef
 = 
_©Œ
; \

97 } 0)

	)

99 
	#MAKE_CONS
(
_»suÉ
,
_v®ue
) \

101 
_»suÉ
 = (
Ex´
 *è
	`m®loc
((Expr)); \

102 
_»suÉ
->
ty³
 = 
EXPR_CONST
; \

103 
_»suÉ
->
ex´
.
cÚs
 = 
_v®ue
; \

104 } 0)

	)

	@record_mgr.h

1 #iâdeà
RECORD_MGR_H


2 
	#RECORD_MGR_H


	)

4 
	~"db”rÜ.h
"

5 
	~"ex´.h
"

6 
	~"bËs.h
"

9 
	sRM_SÿnHªdË


11 
RM_TabËD©a
 *
	m»l
;

12 *
	mmgmtD©a
;

13 } 
	tRM_SÿnHªdË
;

16 
RC
 
š™RecÜdMªag”
 (*
mgmtD©a
);

17 
RC
 
shutdownRecÜdMªag”
 ();

18 
RC
 
ü—‹TabË
 (*
Çme
, 
Schema
 *
schema
);

19 
RC
 
İ’TabË
 (
RM_TabËD©a
 *
»l
, *
Çme
);

20 
RC
 
şo£TabË
 (
RM_TabËD©a
 *
»l
);

21 
RC
 
d–‘eTabË
 (*
Çme
);

22 
g‘NumTu¶es
 (
RM_TabËD©a
 *
»l
);

25 
RC
 
š£¹RecÜd
 (
RM_TabËD©a
 *
»l
, 
RecÜd
 *
»cÜd
);

26 
RC
 
d–‘eRecÜd
 (
RM_TabËD©a
 *
»l
, 
RID
 
id
);

27 
RC
 
upd©eRecÜd
 (
RM_TabËD©a
 *
»l
, 
RecÜd
 *
»cÜd
);

28 
RC
 
g‘RecÜd
 (
RM_TabËD©a
 *
»l
, 
RID
 
id
, 
RecÜd
 *
»cÜd
);

31 
RC
 
¡¬tSÿn
 (
RM_TabËD©a
 *
»l
, 
RM_SÿnHªdË
 *
sÿn
, 
Ex´
 *
cÚd
);

32 
RC
 
Ãxt
 (
RM_SÿnHªdË
 *
sÿn
, 
RecÜd
 *
»cÜd
);

33 
RC
 
şo£Sÿn
 (
RM_SÿnHªdË
 *
sÿn
);

36 
g‘RecÜdSize
 (
Schema
 *
schema
);

37 
Schema
 *
ü—‹Schema
 (
numA‰r
, **
©ŒNames
, 
D©aTy³
 *
d©aTy³s
, *
ty³L’gth
, 
keySize
, *
keys
);

38 
RC
 
ä“Schema
 (
Schema
 *
schema
);

41 
RC
 
ü—‹RecÜd
 (
RecÜd
 **
»cÜd
, 
Schema
 *
schema
);

42 
RC
 
ä“RecÜd
 (
RecÜd
 *
»cÜd
);

43 
RC
 
g‘A‰r
 (
RecÜd
 *
»cÜd
, 
Schema
 *
schema
, 
©ŒNum
, 
V®ue
 **
v®ue
);

44 
RC
 
£tA‰r
 (
RecÜd
 *
»cÜd
, 
Schema
 *
schema
, 
©ŒNum
, 
V®ue
 *
v®ue
);

	@rm_serializer.c

1 
	~<¡dio.h
>

2 
	~<¡dlib.h
>

3 
	~<¡ršg.h
>

5 
	~"db”rÜ.h
"

6 
	~"bËs.h
"

7 
	~"»cÜd_mgr.h
"

10 
	sV¬SŒšg
 {

11 *
	mbuf
;

12 
	msize
;

13 
	mbufsize
;

14 } 
	tV¬SŒšg
;

16 
	#MAKE_VARSTRING
(
v¬
) \

18 
v¬
 = (
V¬SŒšg
 *è
	`m®loc
((VarString)); \

19 
v¬
->
size
 = 0; \

20 
v¬
->
bufsize
 = 100; \

21 
v¬
->
buf
 = 
	`m®loc
(100); \

22 } 0)

	)

24 
	#FREE_VARSTRING
(
v¬
) \

26 
	`ä“
(
v¬
->
buf
); \

27 
	`ä“
(
v¬
); \

28 } 0)

	)

30 
	#GET_STRING
(
»suÉ
, 
v¬
) \

32 
»suÉ
 = 
	`m®loc
((
v¬
->
size
) + 1); \

33 
	`memıy
(
»suÉ
, 
v¬
->
buf
, v¬->
size
); \

34 
»suÉ
[
v¬
->
size
] = '\0'; \

35 } 0)

	)

37 
	#RETURN_STRING
(
v¬
) \

39 *
»suÉSŒ
; \

40 
	`GET_STRING
(
»suÉSŒ
, 
v¬
); \

41 
	`FREE_VARSTRING
(
v¬
); \

42  
»suÉSŒ
; \

43 } 0)

	)

45 
	#ENSURE_SIZE
(
v¬
,
Ãwsize
) \

47 ià(
v¬
->
bufsize
 < 
Ãwsize
) \

49 
Ãwbufsize
 = 
v¬
->
bufsize
; \

50 (
Ãwbufsize
 *ğ2è< 
Ãwsize
); \

51 
v¬
->
buf
 = 
	`»®loc
(v¬->buf, 
Ãwbufsize
); \

53 } 0)

	)

55 
	#APPEND_STRING
(
v¬
,
¡ršg
) \

57 
	`ENSURE_SIZE
(
v¬
, v¬->
size
 + 
	`¡¾’
(
¡ršg
)); \

58 
	`memıy
(
v¬
->
buf
 + v¬->
size
, 
¡ršg
, 
	`¡¾’
(string)); \

59 
v¬
->
size
 +ğ
	`¡¾’
(
¡ršg
); \

60 } 0)

	)

62 
	#APPEND
(
v¬
, ...) \

64 *
tmp
 = 
	`m®loc
(10000); \

65 
	`¥rštf
(
tmp
, 
__VA_ARGS__
); \

66 
	`APPEND_STRING
(
v¬
,
tmp
); \

67 
	`ä“
(
tmp
); \

68 } 0)

	)

71 
RC
 
©ŒOff£t
 (
Schema
 *
schema
, 
©ŒNum
, *
»suÉ
);

75 
	$£rŸlizeTabËInfo
(
RM_TabËD©a
 *
»l
)

77 
V¬SŒšg
 *
»suÉ
;

78 
	`MAKE_VARSTRING
(
»suÉ
);

80 
	`APPEND
(
»suÉ
, "TABLE <%s> w™h <%i>u¶es:\n", 
»l
->
Çme
, 
	`g‘NumTu¶es
(rel));

81 
	`APPEND_STRING
(
»suÉ
, 
	`£rŸlizeSchema
(
»l
->
schema
));

83 
	`RETURN_STRING
(
»suÉ
);

84 
	}
}

87 
	$£rŸlizeTabËCÚ‹Á
(
RM_TabËD©a
 *
»l
)

89 
i
;

90 
V¬SŒšg
 *
»suÉ
;

91 
RM_SÿnHªdË
 *
sc
 = (RM_SÿnHªdË *è
	`m®loc
((RM_ScanHandle));

92 
RecÜd
 *
r
 = (RecÜd *è
	`m®loc
((Record));

93 
	`MAKE_VARSTRING
(
»suÉ
);

95 
i
 = 0; i < 
»l
->
schema
->
numA‰r
; i++)

96 
	`APPEND
(
»suÉ
, "%s%s", (
i
 !ğ0è? ", " : "", 
»l
->
schema
->
©ŒNames
[i]);

98 
	`¡¬tSÿn
(
»l
, 
sc
, 
NULL
);

100 
	`Ãxt
(
sc
, 
r
è!ğ
RC_RM_NO_MORE_TUPLES
)

102 
	`APPEND_STRING
(
»suÉ
,
	`£rŸlizeRecÜd
(
r
, 
»l
->
schema
));

103 
	`APPEND_STRING
(
»suÉ
,"\n");

105 
	`şo£Sÿn
(
sc
);

107 
	`RETURN_STRING
(
»suÉ
);

108 
	}
}

112 
	$£rŸlizeSchema
(
Schema
 *
schema
)

114 
i
;

115 
V¬SŒšg
 *
»suÉ
;

116 
	`MAKE_VARSTRING
(
»suÉ
);

118 
	`APPEND
(
»suÉ
, "Schem¨w™h <%i>‡‰ribu‹ (", 
schema
->
numA‰r
);

120 
i
 = 0; i < 
schema
->
numA‰r
; i++)

122 
	`APPEND
(
»suÉ
,"%s%s: ", (
i
 !ğ0è? ", ": "", 
schema
->
©ŒNames
[i]);

123 
schema
->
d©aTy³s
[
i
])

125 
DT_INT
:

126 
	`APPEND_STRING
(
»suÉ
, "INT");

128 
DT_FLOAT
:

129 
	`APPEND_STRING
(
»suÉ
, "FLOAT");

131 
DT_STRING
:

132 
	`APPEND
(
»suÉ
,"STRING[%i]", 
schema
->
ty³L’gth
[
i
]);

134 
DT_BOOL
:

135 
	`APPEND_STRING
(
»suÉ
,"BOOL");

139 
	`APPEND_STRING
(
»suÉ
,")");

141 
	`APPEND_STRING
(
»suÉ
," with keys: (");

143 
i
 = 0; i < 
schema
->
keySize
; i++)

144 
	`APPEND
(
»suÉ
, "%s%s", ((
i
 !ğ0è? ", ": ""), 
schema
->
©ŒNames
[schema->
keyA‰rs
[i]]);

146 
	`APPEND_STRING
(
»suÉ
,")\n");

148 
	`RETURN_STRING
(
»suÉ
);

149 
	}
}

152 
	$£rŸlizeRecÜd
(
RecÜd
 *
»cÜd
, 
Schema
 *
schema
)

154 
V¬SŒšg
 *
»suÉ
;

155 
	`MAKE_VARSTRING
(
»suÉ
);

156 
i
;

158 
	`APPEND
(
»suÉ
, "[%i-%i] (", 
»cÜd
->
id
.
·ge
,„ecÜd->id.
¦Ù
);

160 
i
 = 0; i < 
schema
->
numA‰r
; i++)

162 
	`APPEND_STRING
(
»suÉ
, 
	`£rŸlizeA‰r
 (
»cÜd
, 
schema
, 
i
));

163 
	`APPEND
(
»suÉ
, "%s", (
i
 == 0) ? "" : ",");

166 
	`APPEND_STRING
(
»suÉ
, ")");

168 
	`RETURN_STRING
(
»suÉ
);

169 
	}
}

172 
	$£rŸlizeA‰r
(
RecÜd
 *
»cÜd
, 
Schema
 *
schema
, 
©ŒNum
)

174 
off£t
;

175 *
©ŒD©a
;

176 
V¬SŒšg
 *
»suÉ
;

177 
	`MAKE_VARSTRING
(
»suÉ
);

179 
	`©ŒOff£t
(
schema
, 
©ŒNum
, &
off£t
);

180 
©ŒD©a
 = 
»cÜd
->
d©a
 + 
off£t
;

182 
schema
->
d©aTy³s
[
©ŒNum
])

184 
DT_INT
:

186 
v®
 = 0;

187 
	`memıy
(&
v®
,
©ŒD©a
, ());

188 
	`APPEND
(
»suÉ
, "%s:%i", 
schema
->
©ŒNames
[
©ŒNum
], 
v®
);

191 
DT_STRING
:

193 *
buf
;

194 
Ën
 = 
schema
->
ty³L’gth
[
©ŒNum
];

195 
buf
 = (*è
	`m®loc
(
Ën
 + 1);

196 
	`¡ºıy
(
buf
, 
©ŒD©a
, 
Ën
);

197 
buf
[
Ën
] = '\0';

199 
	`APPEND
(
»suÉ
, "%s:%s", 
schema
->
©ŒNames
[
©ŒNum
], 
buf
);

200 
	`ä“
(
buf
);

203 
DT_FLOAT
:

205 
v®
;

206 
	`memıy
(&
v®
,
©ŒD©a
, ());

207 
	`APPEND
(
»suÉ
, "%s:%f", 
schema
->
©ŒNames
[
©ŒNum
], 
v®
);

210 
DT_BOOL
:

212 
boŞ
 
v®
;

213 
	`memıy
(&
v®
,
©ŒD©a
, (
boŞ
));

214 
	`APPEND
(
»suÉ
, "%s:%s", 
schema
->
©ŒNames
[
©ŒNum
], 
v®
 ? "TRUE" : "FALSE");

221 
	`RETURN_STRING
(
»suÉ
);

222 
	}
}

225 
	$£rŸlizeV®ue
(
V®ue
 *
v®
)

227 
V¬SŒšg
 *
»suÉ
;

228 
	`MAKE_VARSTRING
(
»suÉ
);

230 
v®
->
dt
)

232 
DT_INT
:

233 
	`APPEND
(
»suÉ
,"%i",
v®
->
v
.
štV
);

235 
DT_FLOAT
:

236 
	`APPEND
(
»suÉ
,"%f", 
v®
->
v
.
æßtV
);

238 
DT_STRING
:

239 
	`APPEND
(
»suÉ
,"%s", 
v®
->
v
.
¡ršgV
);

241 
DT_BOOL
:

242 
	`APPEND_STRING
(
»suÉ
, ((
v®
->
v
.
boŞV
) ? "true" : "false"));

246 
	`RETURN_STRING
(
»suÉ
);

247 
	}
}

249 
V®ue
 *

250 
	$¡ršgToV®ue
(*
v®
)

252 
V®ue
 *
»suÉ
 = (V®u*è
	`m®loc
((Value));

254 
v®
[0])

257 
»suÉ
->
dt
 = 
DT_INT
;

258 
»suÉ
->
v
.
štV
 = 
	`©oi
(
v®
 + 1);

261 
»suÉ
->
dt
 = 
DT_FLOAT
;

262 
»suÉ
->
v
.
æßtV
 = 
	`©of
(
v®
 + 1);

265 
»suÉ
->
dt
 = 
DT_STRING
;

266 
»suÉ
->
v
.
¡ršgV
 = 
	`m®loc
(
	`¡¾’
(
v®
));

267 
	`¡rıy
(
»suÉ
->
v
.
¡ršgV
, 
v®
 + 1);

270 
»suÉ
->
dt
 = 
DT_BOOL
;

271 
»suÉ
->
v
.
boŞV
 = (
v®
[1] =ğ't'è? 
TRUE
 : 
FALSE
;

274 
»suÉ
->
dt
 = 
DT_INT
;

275 
»suÉ
->
v
.
štV
 = -1;

279  
»suÉ
;

280 
	}
}

283 
RC


284 
	$©ŒOff£t
 (
Schema
 *
schema
, 
©ŒNum
, *
»suÉ
)

286 
off£t
 = 0;

287 
©ŒPos
 = 0;

289 
©ŒPos
 = 0;‡‰rPo < 
©ŒNum
;‡ttrPos++)

290 
schema
->
d©aTy³s
[
©ŒPos
])

292 
DT_STRING
:

293 
off£t
 +ğ
schema
->
ty³L’gth
[
©ŒPos
];

295 
DT_INT
:

296 
off£t
 += ();

298 
DT_FLOAT
:

299 
off£t
 += ();

301 
DT_BOOL
:

302 
off£t
 +ğ(
boŞ
);

306 *
»suÉ
 = 
off£t
;

307  
RC_OK
;

308 
	}
}

	@storage_mgr.h

1 #iâdeà
STORAGE_MGR_H


2 
	#STORAGE_MGR_H


	)

4 
	~"db”rÜ.h
"

9 
	sSM_FeHªdË
 {

10 *
	mfeName
;

11 
	mtÙ®NumPages
;

12 
	mcurPagePos
;

13 *
	mmgmtInfo
;

14 } 
	tSM_FeHªdË
;

16 * 
	tSM_PageHªdË
;

22 
š™StÜageMªag”
 ();

23 
RC
 
ü—‹PageFe
 (*
feName
);

24 
RC
 
İ’PageFe
 (*
feName
, 
SM_FeHªdË
 *
fHªdË
);

25 
RC
 
şo£PageFe
 (
SM_FeHªdË
 *
fHªdË
);

26 
RC
 
de¡royPageFe
 (*
feName
);

29 
RC
 
»adBlock
 (
·geNum
, 
SM_FeHªdË
 *
fHªdË
, 
SM_PageHªdË
 
memPage
);

30 
g‘BlockPos
 (
SM_FeHªdË
 *
fHªdË
);

31 
RC
 
»adFœ¡Block
 (
SM_FeHªdË
 *
fHªdË
, 
SM_PageHªdË
 
memPage
);

32 
RC
 
»adP»viousBlock
 (
SM_FeHªdË
 *
fHªdË
, 
SM_PageHªdË
 
memPage
);

33 
RC
 
»adCu¼’tBlock
 (
SM_FeHªdË
 *
fHªdË
, 
SM_PageHªdË
 
memPage
);

34 
RC
 
»adNextBlock
 (
SM_FeHªdË
 *
fHªdË
, 
SM_PageHªdË
 
memPage
);

35 
RC
 
»adLa¡Block
 (
SM_FeHªdË
 *
fHªdË
, 
SM_PageHªdË
 
memPage
);

38 
RC
 
wr™eBlock
 (
·geNum
, 
SM_FeHªdË
 *
fHªdË
, 
SM_PageHªdË
 
memPage
);

39 
RC
 
wr™eCu¼’tBlock
 (
SM_FeHªdË
 *
fHªdË
, 
SM_PageHªdË
 
memPage
);

40 
RC
 
­³ndEm±yBlock
 (
SM_FeHªdË
 *
fHªdË
);

41 
RC
 
’su»C­ac™y
 (
numb”OfPages
, 
SM_FeHªdË
 *
fHªdË
);

	@tables.h

1 #iâdeà
TABLES_H


2 
	#TABLES_H


	)

4 
	~"dt.h
"

7 
	eD©aTy³
 {

8 
	mDT_INT
 = 0,

9 
	mDT_STRING
 = 1,

10 
	mDT_FLOAT
 = 2,

11 
	mDT_BOOL
 = 3

12 } 
	tD©aTy³
;

14 
	sV®ue
 {

15 
D©aTy³
 
	mdt
;

16 
	uv
 {

17 
	mštV
;

18 *
	m¡ršgV
;

19 
	mæßtV
;

20 
boŞ
 
	mboŞV
;

21 } 
	mv
;

22 } 
	tV®ue
;

24 
	sRID
 {

25 
	m·ge
;

26 
	m¦Ù
;

27 } 
	tRID
;

29 
	sRecÜd


31 
RID
 
	mid
;

32 *
	md©a
;

33 } 
	tRecÜd
;

36 
	sSchema


38 
	mnumA‰r
;

39 **
	m©ŒNames
;

40 
D©aTy³
 *
	md©aTy³s
;

41 *
	mty³L’gth
;

42 *
	mkeyA‰rs
;

43 
	mkeySize
;

44 } 
	tSchema
;

47 
	sRM_TabËD©a


49 *
	mÇme
;

50 
Schema
 *
	mschema
;

51 *
	mmgmtD©a
;

52 } 
	tRM_TabËD©a
;

54 
	#MAKE_STRING_VALUE
(
»suÉ
, 
v®ue
) \

56 (
»suÉ
èğ(
V®ue
 *è
	`m®loc
((Value)); \

57 (
»suÉ
)->
dt
 = 
DT_STRING
; \

58 (
»suÉ
)->
v
.
¡ršgV
 = (*è
	`m®loc
(
	`¡¾’
(
v®ue
) + 1); \

59 
	`¡rıy
((
»suÉ
)->
v
.
¡ršgV
, 
v®ue
); \

60 } 0)

	)

63 
	#MAKE_VALUE
(
»suÉ
, 
d©©y³
, 
v®ue
) \

65 (
»suÉ
èğ(
V®ue
 *è
	`m®loc
((Value)); \

66 (
»suÉ
)->
dt
 = 
d©©y³
; \

67 
d©©y³
) \

69 
DT_INT
: \

70 (
»suÉ
)->
v
.
štV
 = 
v®ue
; \

72 
DT_FLOAT
: \

73 (
»suÉ
)->
v
.
æßtV
 = 
v®ue
; \

75 
DT_BOOL
: \

76 (
»suÉ
)->
v
.
boŞV
 = 
v®ue
; \

79 } 0)

	)

83 
V®ue
 *
¡ršgToV®ue
 (*
v®ue
);

84 *
£rŸlizeTabËInfo
(
RM_TabËD©a
 *
»l
);

85 *
£rŸlizeTabËCÚ‹Á
(
RM_TabËD©a
 *
»l
);

86 *
£rŸlizeSchema
(
Schema
 *
schema
);

87 *
£rŸlizeRecÜd
(
RecÜd
 *
»cÜd
, 
Schema
 *
schema
);

88 *
£rŸlizeA‰r
(
RecÜd
 *
»cÜd
, 
Schema
 *
schema
, 
©ŒNum
);

89 *
£rŸlizeV®ue
(
V®ue
 *
v®
);

	@test_assign3_1.c

1 
	~<¡dlib.h
>

2 
	~"db”rÜ.h
"

3 
	~"ex´.h
"

4 
	~"»cÜd_mgr.h
"

5 
	~"bËs.h
"

6 
	~"‹¡_h–³r.h
"

9 
	#ASSERT_EQUALS_RECORDS
(
_l
,
_r
, 
schema
, 
mes§ge
) \

11 
RecÜd
 *
_lR
 = 
_l
; \

12 
RecÜd
 *
_rR
 = 
_r
; \

13 
	`ASSERT_TRUE
(
	`memcmp
(
_lR
->
d©a
,
_rR
->d©a,
	`g‘RecÜdSize
(
schema
)è=ğ0, 
mes§ge
); \

14 
i
; \

15 
i
 = 0; i < 
schema
->
numA‰r
; i++) \

17 
V®ue
 *
lV®
, *
rV®
; \

18 *
lS”
, *
rS”
; \

19 
	`g‘A‰r
(
_lR
, 
schema
, 
i
, &
lV®
); \

20 
	`g‘A‰r
(
_rR
, 
schema
, 
i
, &
rV®
); \

21 
lS”
 = 
	`£rŸlizeV®ue
(
lV®
); \

22 
rS”
 = 
	`£rŸlizeV®ue
(
rV®
); \

23 
	`ASSERT_EQUALS_STRING
(
lS”
, 
rS”
, "attr same"); \

24 
	`ä“
(
lV®
); \

25 
	`ä“
(
rV®
); \

26 
	`ä“
(
lS”
); \

27 
	`ä“
(
rS”
); \

29 } 0)

	)

31 
	#ASSERT_EQUALS_RECORD_IN
(
_l
,
_r
, 
rSize
, 
schema
, 
mes§ge
) \

33 
i
; \

34 
boŞ—n
 
found
 = 
çl£
; \

35 
i
 = 0; i < 
rSize
; i++) \

36 ià(
	`memcmp
(
_l
->
d©a
,
_r
[
i
]->d©a,
	`g‘RecÜdSize
(
schema
)) == 0) \

37 
found
 = 
Œue
; \

38 
	`ASSERT_TRUE
(0, 
mes§ge
); \

39 } 0)

	)

41 
	#OP_TRUE
(
Ëá
, 
right
, 
İ
, 
mes§ge
) \

43 
V®ue
 *
»suÉ
 = (V®u*è
	`m®loc
((Value)); \

44 
	`İ
(
Ëá
, 
right
, 
»suÉ
); \

45 
boŞ
 
b
 = 
»suÉ
->
v
.
boŞV
; \

46 
	`ä“
(
»suÉ
); \

47 
	`ASSERT_TRUE
(
b
,
mes§ge
); \

48 } 0)

	)

51 
‹¡RecÜds
 ();

52 
‹¡C»©eTabËAndIn£¹
 ();

53 
‹¡Upd©eTabË
 ();

54 
‹¡Sÿns
 ();

55 
‹¡SÿnsTwo
 ();

56 
‹¡In£¹MªyRecÜds
();

57 
‹¡MuÉËSÿns
();

60 
	sTe¡RecÜd
 {

61 
	ma
;

62 *
	mb
;

63 
	mc
;

64 } 
	tTe¡RecÜd
;

67 
RecÜd
 *
‹¡RecÜd
(
Schema
 *
schema
, 
a
, *
b
, 
c
);

68 
Schema
 *
‹¡Schema
 ();

69 
RecÜd
 *
äomTe¡RecÜd
 (
Schema
 *
schema
, 
Te¡RecÜd
 
š
);

72 *
	g‹¡Name
;

76 
	$maš
 ()

78 
‹¡Name
 = "";

80 
	`‹¡In£¹MªyRecÜds
();

81 
	`‹¡RecÜds
();

82 
	`‹¡C»©eTabËAndIn£¹
();

83 
	`‹¡Upd©eTabË
();

84 
	`‹¡Sÿns
();

85 
	`‹¡SÿnsTwo
();

86 
	`‹¡MuÉËSÿns
();

89 
	}
}

93 
	$‹¡RecÜds
 ()

95 
Te¡RecÜd
 
ex³ùed
[] = {

98 
Schema
 *
schema
;

99 
RecÜd
 *
r
;

100 
V®ue
 *
v®ue
;

101 
‹¡Name
 = "test creating„ecords‡nd manipulating‡ttributes";

104 
schema
 = 
	`‹¡Schema
();

105 
r
 = 
	`äomTe¡RecÜd
(
schema
, 
ex³ùed
[0]);

107 
	`g‘A‰r
(
r
, 
schema
, 0, &
v®ue
);

108 
	`OP_TRUE
(
	`¡ršgToV®ue
("i1"), 
v®ue
, 
v®ueEqu®s
, "first‡ttr");

109 
	`ä“V®
(
v®ue
);

111 
	`g‘A‰r
(
r
, 
schema
, 1, &
v®ue
);

112 
	`OP_TRUE
(
	`¡ršgToV®ue
("§¯a"), 
v®ue
, 
v®ueEqu®s
, "second‡ttr");

113 
	`ä“V®
(
v®ue
);

115 
	`g‘A‰r
(
r
, 
schema
, 2, &
v®ue
);

116 
	`OP_TRUE
(
	`¡ršgToV®ue
("i3"), 
v®ue
, 
v®ueEqu®s
, "third‡ttr");

117 
	`ä“V®
(
v®ue
);

120 
	`£tA‰r
(
r
, 
schema
, 2, 
	`¡ršgToV®ue
("i4"));

121 
	`g‘A‰r
(
r
, 
schema
, 2, &
v®ue
);

122 
	`OP_TRUE
(
	`¡ršgToV®ue
("i4"), 
v®ue
, 
v®ueEqu®s
, "third‡ttr‡fter setting");

123 
	`ä“V®
(
v®ue
);

125 
	`ä“RecÜd
(
r
);

126 
	`TEST_DONE
();

127 
	}
}

131 
	$‹¡C»©eTabËAndIn£¹
 ()

133 
RM_TabËD©a
 *
bË
 = (RM_TabËD©¨*è
	`m®loc
((RM_TableData));

134 
Te¡RecÜd
 
š£¹s
[] = {

145 
numIn£¹s
 = 9, 
i
;

146 
RecÜd
 *
r
;

147 
RID
 *
rids
;

148 
Schema
 *
schema
;

149 
‹¡Name
 = "test creating‡‚ewable‡nd insertinguples";

150 
schema
 = 
	`‹¡Schema
();

151 
rids
 = (
RID
 *è
	`m®loc
((RIDè* 
numIn£¹s
);

153 
	`TEST_CHECK
(
	`š™RecÜdMªag”
(
NULL
));

154 
	`TEST_CHECK
(
	`ü—‹TabË
("‹¡_bË_r",
schema
));

155 
	`TEST_CHECK
(
	`İ’TabË
(
bË
, "test_table_r"));

158 
i
 = 0; i < 
numIn£¹s
; i++)

160 
r
 = 
	`äomTe¡RecÜd
(
schema
, 
š£¹s
[
i
]);

161 
	`TEST_CHECK
(
	`š£¹RecÜd
(
bË
,
r
));

162 
rids
[
i
] = 
r
->
id
;

165 
	`TEST_CHECK
(
	`şo£TabË
(
bË
));

166 
	`TEST_CHECK
(
	`İ’TabË
(
bË
, "test_table_r"));

169 
i
 = 0; i < 1000; i++)

171 
pos
 = 
	`¿nd
(è% 
numIn£¹s
;

172 
RID
 
rid
 = 
rids
[
pos
];

173 
	`TEST_CHECK
(
	`g‘RecÜd
(
bË
, 
rid
, 
r
));

174 
	`ASSERT_EQUALS_RECORDS
(
	`äomTe¡RecÜd
(
schema
, 
š£¹s
[
pos
]), 
r
, schema, "compare„ecords");

177 
	`TEST_CHECK
(
	`şo£TabË
(
bË
));

178 
	`TEST_CHECK
(
	`d–‘eTabË
("test_table_r"));

179 
	`TEST_CHECK
(
	`shutdownRecÜdMªag”
());

181 
	`ä“
(
rids
);

182 
	`ä“
(
bË
);

183 
	`TEST_DONE
();

184 
	}
}

187 
	$‹¡MuÉËSÿns
()

189 
RM_TabËD©a
 *
bË
 = (RM_TabËD©¨*è
	`m®loc
((RM_TableData));

190 
Te¡RecÜd
 
š£¹s
[] = {

202 
numIn£¹s
 = 10, 
i
, 
sÿnOÃ
=0, 
sÿnTwo
=0;

203 
RecÜd
 *
r
;

204 
RID
 *
rids
;

205 
Schema
 *
schema
;

206 
‹¡Name
 = "test„unning muliple scans ";

207 
schema
 = 
	`‹¡Schema
();

208 
rids
 = (
RID
 *è
	`m®loc
((RIDè* 
numIn£¹s
);

209 
RM_SÿnHªdË
 *
sc1
 = (RM_SÿnHªdË *è
	`m®loc
((RM_ScanHandle));

210 
RM_SÿnHªdË
 *
sc2
 = (RM_SÿnHªdË *è
	`m®loc
((RM_ScanHandle));

211 
Ex´
 *
£1
, *
Ëá
, *
right
;

212 
rc
,
rc2
;

214 
	`TEST_CHECK
(
	`š™RecÜdMªag”
(
NULL
));

215 
	`TEST_CHECK
(
	`ü—‹TabË
("‹¡_bË_r",
schema
));

216 
	`TEST_CHECK
(
	`İ’TabË
(
bË
, "test_table_r"));

219 
i
 = 0; i < 
numIn£¹s
; i++)

221 
r
 = 
	`äomTe¡RecÜd
(
schema
, 
š£¹s
[
i
]);

222 
	`TEST_CHECK
(
	`š£¹RecÜd
(
bË
,
r
));

223 
rids
[
i
] = 
r
->
id
;

227 
	`MAKE_CONS
(
Ëá
, 
	`¡ršgToV®ue
("i3"));

228 
	`MAKE_ATTRREF
(
right
, 2);

229 
	`MAKE_BINOP_EXPR
(
£1
, 
Ëá
, 
right
, 
OP_COMP_EQUAL
);

230 
	`ü—‹RecÜd
(&
r
, 
schema
);

231 
	`TEST_CHECK
(
	`¡¬tSÿn
(
bË
, 
sc1
, 
£1
));

232 
	`TEST_CHECK
(
	`¡¬tSÿn
(
bË
, 
sc2
, 
£1
));

233 ià((
rc2
 = 
	`Ãxt
(
sc2
, 
r
)è=ğ
RC_OK
)

234 
sÿnTwo
++;

235 
i
 = 0;

236 (
rc
 = 
	`Ãxt
(
sc1
, 
r
)è=ğ
RC_OK
)

238 
sÿnOÃ
++;

239 
i
++;

240 ià(
i
 % 3 == 0)

241 ià((
rc2
 = 
	`Ãxt
(
sc2
, 
r
)è=ğ
RC_OK
)

242 
sÿnTwo
++;

244 (
rc2
 = 
	`Ãxt
(
sc2
, 
r
)è=ğ
RC_OK
)

245 
sÿnTwo
++;

247 
	`ASSERT_TRUE
(
sÿnOÃ
 =ğ
sÿnTwo
, "scans„eturned same‚umber ofuples");

248 ià(
rc
 !ğ
RC_RM_NO_MORE_TUPLES
)

249 
	`TEST_CHECK
(
rc
);

250 
	`TEST_CHECK
(
	`şo£Sÿn
(
sc1
));

251 
	`TEST_CHECK
(
	`şo£Sÿn
(
sc2
));

253 
	`TEST_CHECK
(
	`şo£TabË
(
bË
));

254 
	`TEST_CHECK
(
	`d–‘eTabË
("test_table_r"));

255 
	`TEST_CHECK
(
	`shutdownRecÜdMªag”
());

257 
	`ä“
(
rids
);

258 
	`ä“
(
bË
);

259 
	`TEST_DONE
();

260 
	}
}

263 
	$‹¡Upd©eTabË
 ()

265 
RM_TabËD©a
 *
bË
 = (RM_TabËD©¨*è
	`m®loc
((RM_TableData));

266 
Te¡RecÜd
 
š£¹s
[] = {

278 
Te¡RecÜd
 
upd©es
[] = {

283 
d–‘es
[] = {

290 
Te¡RecÜd
 
fš®R
[] = {

297 
numIn£¹s
 = 10, 
numUpd©es
 = 3, 
numD–‘es
 = 5, 
numFš®
 = 5, 
i
;

298 
RecÜd
 *
r
;

299 
RID
 *
rids
;

300 
Schema
 *
schema
;

301 
‹¡Name
 = "test creating‡‚ewable‡nd insert,update,deleteuples";

302 
schema
 = 
	`‹¡Schema
();

303 
rids
 = (
RID
 *è
	`m®loc
((RIDè* 
numIn£¹s
);

305 
	`TEST_CHECK
(
	`š™RecÜdMªag”
(
NULL
));

306 
	`TEST_CHECK
(
	`ü—‹TabË
("‹¡_bË_r",
schema
));

307 
	`TEST_CHECK
(
	`İ’TabË
(
bË
, "test_table_r"));

310 
i
 = 0; i < 
numIn£¹s
; i++)

312 
r
 = 
	`äomTe¡RecÜd
(
schema
, 
š£¹s
[
i
]);

313 
	`TEST_CHECK
(
	`š£¹RecÜd
(
bË
,
r
));

314 
rids
[
i
] = 
r
->
id
;

318 
i
 = 0; i < 
numD–‘es
; i++)

320 
	`TEST_CHECK
(
	`d–‘eRecÜd
(
bË
,
rids
[
d–‘es
[
i
]]));

324 
i
 = 0; i < 
numUpd©es
; i++)

326 
r
 = 
	`äomTe¡RecÜd
(
schema
, 
upd©es
[
i
]);

327 
r
->
id
 = 
rids
[
i
];

328 
	`TEST_CHECK
(
	`upd©eRecÜd
(
bË
,
r
));

331 
	`TEST_CHECK
(
	`şo£TabË
(
bË
));

332 
	`TEST_CHECK
(
	`İ’TabË
(
bË
, "test_table_r"));

335 
i
 = 0; i < 
numFš®
; i++)

337 
RID
 
rid
 = 
rids
[
i
];

338 
	`TEST_CHECK
(
	`g‘RecÜd
(
bË
, 
rid
, 
r
));

339 
	`ASSERT_EQUALS_RECORDS
(
	`äomTe¡RecÜd
(
schema
, 
fš®R
[
i
]), 
r
, schema, "compare„ecords");

342 
	`TEST_CHECK
(
	`şo£TabË
(
bË
));

343 
	`TEST_CHECK
(
	`d–‘eTabË
("test_table_r"));

344 
	`TEST_CHECK
(
	`shutdownRecÜdMªag”
());

346 
	`ä“
(
bË
);

347 
	`TEST_DONE
();

348 
	}
}

351 
	$‹¡In£¹MªyRecÜds
()

353 
RM_TabËD©a
 *
bË
 = (RM_TabËD©¨*è
	`m®loc
((RM_TableData));

354 
Te¡RecÜd
 
š£¹s
[] = {

366 
Te¡RecÜd
 
»®In£¹s
[10000];

367 
Te¡RecÜd
 
upd©es
[] = {

370 
numIn£¹s
 = 10000, 
i
;

371 
¿ndomRec
 = 3333;

372 
RecÜd
 *
r
;

373 
RID
 *
rids
;

374 
Schema
 *
schema
;

375 
‹¡Name
 = "test creating‡‚ewable‡nd inserting 10000„ecordshen updating„ecord from„ids[3333]";

376 
schema
 = 
	`‹¡Schema
();

377 
rids
 = (
RID
 *è
	`m®loc
((RIDè* 
numIn£¹s
);

379 
	`TEST_CHECK
(
	`š™RecÜdMªag”
(
NULL
));

380 
	`TEST_CHECK
(
	`ü—‹TabË
("‹¡_bË_t",
schema
));

381 
	`TEST_CHECK
(
	`İ’TabË
(
bË
, "test_table_t"));

384 
i
 = 0; i < 
numIn£¹s
; i++)

386 
»®In£¹s
[
i
] = 
š£¹s
[i%10];

387 
»®In£¹s
[
i
].
a
 = i;

388 
r
 = 
	`äomTe¡RecÜd
(
schema
, 
»®In£¹s
[
i
]);

389 
	`TEST_CHECK
(
	`š£¹RecÜd
(
bË
,
r
));

390 
rids
[
i
] = 
r
->
id
;

392 
	`TEST_CHECK
(
	`şo£TabË
(
bË
));

393 
	`TEST_CHECK
(
	`İ’TabË
(
bË
, "test_table_t"));

396 
i
 = 0; i < 
numIn£¹s
; i++)

398 
RID
 
rid
 = 
rids
[
i
];

399 
	`TEST_CHECK
(
	`g‘RecÜd
(
bË
, 
rid
, 
r
));

400 
	`ASSERT_EQUALS_RECORDS
(
	`äomTe¡RecÜd
(
schema
, 
»®In£¹s
[
i
]), 
r
, schema, "compare„ecords");

403 
r
 = 
	`äomTe¡RecÜd
(
schema
, 
upd©es
[0]);

404 
r
->
id
 = 
rids
[
¿ndomRec
];

405 
	`TEST_CHECK
(
	`upd©eRecÜd
(
bË
,
r
));

406 
	`TEST_CHECK
(
	`g‘RecÜd
(
bË
, 
rids
[
¿ndomRec
], 
r
));

407 
	`ASSERT_EQUALS_RECORDS
(
	`äomTe¡RecÜd
(
schema
, 
upd©es
[0]), 
r
, schema, "compare„ecords");

409 
	`TEST_CHECK
(
	`şo£TabË
(
bË
));

410 
	`TEST_CHECK
(
	`d–‘eTabË
("test_table_t"));

411 
	`TEST_CHECK
(
	`shutdownRecÜdMªag”
());

413 
	`ä“RecÜd
(
r
);

414 
	`ä“
(
bË
);

415 
	`TEST_DONE
();

416 
	}
}

418 
	$‹¡Sÿns
 ()

420 
RM_TabËD©a
 *
bË
 = (RM_TabËD©¨*è
	`m®loc
((RM_TableData));

421 
Te¡RecÜd
 
š£¹s
[] = {

433 
Te¡RecÜd
 
sÿnOÃResuÉ
[] = {

437 
boŞ
 
foundSÿn
[] = {

438 
FALSE
,

439 
FALSE


441 
numIn£¹s
 = 10, 
sÿnSizeOÃ
 = 2, 
i
;

442 
RecÜd
 *
r
;

443 
RID
 *
rids
;

444 
Schema
 *
schema
;

445 
RM_SÿnHªdË
 *
sc
 = (RM_SÿnHªdË *è
	`m®loc
((RM_ScanHandle));

446 
Ex´
 *
£l
, *
Ëá
, *
right
;

447 
rc
;

449 
‹¡Name
 = "test creating‡‚ewable‡nd insertinguples";

450 
schema
 = 
	`‹¡Schema
();

451 
rids
 = (
RID
 *è
	`m®loc
((RIDè* 
numIn£¹s
);

453 
	`TEST_CHECK
(
	`š™RecÜdMªag”
(
NULL
));

454 
	`TEST_CHECK
(
	`ü—‹TabË
("‹¡_bË_r",
schema
));

455 
	`TEST_CHECK
(
	`İ’TabË
(
bË
, "test_table_r"));

458 
i
 = 0; i < 
numIn£¹s
; i++)

460 
r
 = 
	`äomTe¡RecÜd
(
schema
, 
š£¹s
[
i
]);

461 
	`TEST_CHECK
(
	`š£¹RecÜd
(
bË
,
r
));

462 
rids
[
i
] = 
r
->
id
;

465 
	`TEST_CHECK
(
	`şo£TabË
(
bË
));

466 
	`TEST_CHECK
(
	`İ’TabË
(
bË
, "test_table_r"));

469 
	`MAKE_CONS
(
Ëá
, 
	`¡ršgToV®ue
("i1"));

470 
	`MAKE_ATTRREF
(
right
, 2);

471 
	`MAKE_BINOP_EXPR
(
£l
, 
Ëá
, 
right
, 
OP_COMP_EQUAL
);

473 
	`TEST_CHECK
(
	`¡¬tSÿn
(
bË
, 
sc
, 
£l
));

474 (
rc
 = 
	`Ãxt
(
sc
, 
r
)è=ğ
RC_OK
)

476 
i
 = 0; i < 
sÿnSizeOÃ
; i++)

478 ià(
	`memcmp
(
	`äomTe¡RecÜd
(
schema
, 
sÿnOÃResuÉ
[
i
])->
d©a
,
r
->d©a,
	`g‘RecÜdSize
(schema)) == 0)

479 
foundSÿn
[
i
] = 
TRUE
;

482 ià(
rc
 !ğ
RC_RM_NO_MORE_TUPLES
)

483 
	`TEST_CHECK
(
rc
);

484 
	`TEST_CHECK
(
	`şo£Sÿn
(
sc
));

485 
i
 = 0; i < 
sÿnSizeOÃ
; i++)

486 
	`ASSERT_TRUE
(
foundSÿn
[
i
], "check for scan„esult");

489 
	`TEST_CHECK
(
	`şo£TabË
(
bË
));

490 
	`TEST_CHECK
(
	`d–‘eTabË
("test_table_r"));

491 
	`TEST_CHECK
(
	`shutdownRecÜdMªag”
());

493 
	`ä“
(
bË
);

494 
	`ä“
(
sc
);

495 
	`ä“Ex´
(
£l
);

496 
	`TEST_DONE
();

497 
	}
}

500 
	$‹¡SÿnsTwo
 ()

502 
RM_TabËD©a
 *
bË
 = (RM_TabËD©¨*è
	`m®loc
((RM_TableData));

503 
Te¡RecÜd
 
š£¹s
[] = {

515 
boŞ
 
foundSÿn
[] = {

516 
FALSE
,

517 
FALSE
,

518 
FALSE
,

519 
FALSE
,

520 
FALSE
,

521 
FALSE
,

522 
FALSE
,

523 
FALSE
,

524 
FALSE
,

525 
FALSE


527 
numIn£¹s
 = 10, 
i
;

528 
RecÜd
 *
r
;

529 
RID
 *
rids
;

530 
Schema
 *
schema
;

531 
RM_SÿnHªdË
 *
sc
 = (RM_SÿnHªdË *è
	`m®loc
((RM_ScanHandle));

532 
Ex´
 *
£l
, *
Ëá
, *
right
, *
fœ¡
, *
£
;

533 
rc
;

535 
‹¡Name
 = "test creating‡‚ewable‡nd insertinguples";

536 
schema
 = 
	`‹¡Schema
();

537 
rids
 = (
RID
 *è
	`m®loc
((RIDè* 
numIn£¹s
);

539 
	`TEST_CHECK
(
	`š™RecÜdMªag”
(
NULL
));

540 
	`TEST_CHECK
(
	`ü—‹TabË
("‹¡_bË_r",
schema
));

541 
	`TEST_CHECK
(
	`İ’TabË
(
bË
, "test_table_r"));

544 
i
 = 0; i < 
numIn£¹s
; i++)

546 
r
 = 
	`äomTe¡RecÜd
(
schema
, 
š£¹s
[
i
]);

547 
	`TEST_CHECK
(
	`š£¹RecÜd
(
bË
,
r
));

548 
rids
[
i
] = 
r
->
id
;

551 
	`TEST_CHECK
(
	`şo£TabË
(
bË
));

552 
	`TEST_CHECK
(
	`İ’TabË
(
bË
, "test_table_r"));

555 
	`MAKE_CONS
(
Ëá
, 
	`¡ršgToV®ue
("i2"));

556 
	`MAKE_ATTRREF
(
right
, 0);

557 
	`MAKE_BINOP_EXPR
(
£l
, 
Ëá
, 
right
, 
OP_COMP_EQUAL
);

558 
	`ü—‹RecÜd
(&
r
, 
schema
);

559 
	`TEST_CHECK
(
	`¡¬tSÿn
(
bË
, 
sc
, 
£l
));

560 (
rc
 = 
	`Ãxt
(
sc
, 
r
)è=ğ
RC_OK
)

562 
	`ASSERT_EQUALS_RECORDS
(
	`äomTe¡RecÜd
(
schema
, 
š£¹s
[1]), 
r
, schema, "compare„ecords");

564 ià(
rc
 !ğ
RC_RM_NO_MORE_TUPLES
)

565 
	`TEST_CHECK
(
rc
);

566 
	`TEST_CHECK
(
	`şo£Sÿn
(
sc
));

569 
	`MAKE_CONS
(
Ëá
, 
	`¡ršgToV®ue
("sffff"));

570 
	`MAKE_ATTRREF
(
right
, 1);

571 
	`MAKE_BINOP_EXPR
(
£l
, 
Ëá
, 
right
, 
OP_COMP_EQUAL
);

572 
	`ü—‹RecÜd
(&
r
, 
schema
);

573 
	`TEST_CHECK
(
	`¡¬tSÿn
(
bË
, 
sc
, 
£l
));

574 (
rc
 = 
	`Ãxt
(
sc
, 
r
)è=ğ
RC_OK
)

576 
	`ASSERT_EQUALS_RECORDS
(
	`äomTe¡RecÜd
(
schema
, 
š£¹s
[5]), 
r
, schema, "compare„ecords");

577 
	`£rŸlizeRecÜd
(
r
, 
schema
);

579 ià(
rc
 !ğ
RC_RM_NO_MORE_TUPLES
)

580 
	`TEST_CHECK
(
rc
);

581 
	`TEST_CHECK
(
	`şo£Sÿn
(
sc
));

584 
	`MAKE_CONS
(
Ëá
, 
	`¡ršgToV®ue
("i4"));

585 
	`MAKE_ATTRREF
(
right
, 2);

586 
	`MAKE_BINOP_EXPR
(
fœ¡
, 
right
, 
Ëá
, 
OP_COMP_SMALLER
);

587 
	`MAKE_UNOP_EXPR
(
£
, 
fœ¡
, 
OP_BOOL_NOT
);

588 
	`TEST_CHECK
(
	`¡¬tSÿn
(
bË
, 
sc
, 
£
));

589 (
rc
 = 
	`Ãxt
(
sc
, 
r
)è=ğ
RC_OK
)

591 
	`£rŸlizeRecÜd
(
r
, 
schema
);

592 
i
 = 0; i < 
numIn£¹s
; i++)

594 ià(
	`memcmp
(
	`äomTe¡RecÜd
(
schema
, 
š£¹s
[
i
])->
d©a
,
r
->d©a,
	`g‘RecÜdSize
(schema)) == 0)

595 
foundSÿn
[
i
] = 
TRUE
;

598 ià(
rc
 !ğ
RC_RM_NO_MORE_TUPLES
)

599 
	`TEST_CHECK
(
rc
);

600 
	`TEST_CHECK
(
	`şo£Sÿn
(
sc
));

602 
	`ASSERT_TRUE
(!
foundSÿn
[0], "not greaterhan four");

603 
	`ASSERT_TRUE
(
foundSÿn
[4], "greaterhan four");

604 
	`ASSERT_TRUE
(
foundSÿn
[9], "greaterhan four");

607 
	`TEST_CHECK
(
	`şo£TabË
(
bË
));

608 
	`TEST_CHECK
(
	`d–‘eTabË
("test_table_r"));

609 
	`TEST_CHECK
(
	`shutdownRecÜdMªag”
());

611 
	`ä“RecÜd
(
r
);

612 
	`ä“
(
bË
);

613 
	`ä“
(
sc
);

614 
	`ä“Ex´
(
£l
);

615 
	`TEST_DONE
();

616 
	}
}

619 
Schema
 *

620 
	$‹¡Schema
 ()

622 
Schema
 *
»suÉ
;

623 *
Çmes
[] = { "a", "b", "c" };

624 
D©aTy³
 
dt
[] = { 
DT_INT
, 
DT_STRING
, DT_INT };

625 
sizes
[] = { 0, 4, 0 };

626 
keys
[] = {0};

627 
i
;

628 **
ıNames
 = (**è
	`m®loc
((*) * 3);

629 
D©aTy³
 *
ıDt
 = (D©aTy³ *è
	`m®loc
((DataType) * 3);

630 *
ıSizes
 = (*è
	`m®loc
(() * 3);

631 *
ıKeys
 = (*è
	`m®loc
(());

633 
i
 = 0; i < 3; i++)

635 
ıNames
[
i
] = (*è
	`m®loc
(2);

636 
	`¡rıy
(
ıNames
[
i
], 
Çmes
[i]);

638 
	`memıy
(
ıDt
, 
dt
, (
D©aTy³
) * 3);

639 
	`memıy
(
ıSizes
, 
sizes
, () * 3);

640 
	`memıy
(
ıKeys
, 
keys
, ());

642 
»suÉ
 = 
	`ü—‹Schema
(3, 
ıNames
, 
ıDt
, 
ıSizes
, 1, 
ıKeys
);

644  
»suÉ
;

645 
	}
}

647 
RecÜd
 *

648 
	$äomTe¡RecÜd
 (
Schema
 *
schema
, 
Te¡RecÜd
 
š
)

650  
	`‹¡RecÜd
(
schema
, 
š
.
a
, in.
b
, in.
c
);

651 
	}
}

653 
RecÜd
 *

654 
	$‹¡RecÜd
(
Schema
 *
schema
, 
a
, *
b
, 
c
)

656 
RecÜd
 *
»suÉ
;

657 
V®ue
 *
v®ue
;

659 
	`TEST_CHECK
(
	`ü—‹RecÜd
(&
»suÉ
, 
schema
));

661 
	`MAKE_VALUE
(
v®ue
, 
DT_INT
, 
a
);

662 
	`TEST_CHECK
(
	`£tA‰r
(
»suÉ
, 
schema
, 0, 
v®ue
));

663 
	`ä“V®
(
v®ue
);

665 
	`MAKE_STRING_VALUE
(
v®ue
, 
b
);

666 
	`TEST_CHECK
(
	`£tA‰r
(
»suÉ
, 
schema
, 1, 
v®ue
));

667 
	`ä“V®
(
v®ue
);

669 
	`MAKE_VALUE
(
v®ue
, 
DT_INT
, 
c
);

670 
	`TEST_CHECK
(
	`£tA‰r
(
»suÉ
, 
schema
, 2, 
v®ue
));

671 
	`ä“V®
(
v®ue
);

673  
»suÉ
;

674 
	}
}

	@test_expr.c

1 
	~"db”rÜ.h
"

2 
	~"ex´.h
"

3 
	~"»cÜd_mgr.h
"

4 
	~"bËs.h
"

5 
	~"‹¡_h–³r.h
"

8 
	#OP_TRUE
(
Ëá
, 
right
, 
İ
, 
mes§ge
) \

10 
V®ue
 *
»suÉ
; \

11 
	`MAKE_VALUE
(
»suÉ
, 
DT_INT
, -1); \

12 
	`İ
(
Ëá
, 
right
, 
»suÉ
); \

13 
boŞ
 
b
 = 
»suÉ
->
v
.
boŞV
; \

14 
	`ä“
(
»suÉ
); \

15 
	`ASSERT_TRUE
(
b
,
mes§ge
); \

16 } 0)

	)

18 
	#OP_FALSE
(
Ëá
, 
right
, 
İ
, 
mes§ge
) \

20 
V®ue
 *
»suÉ
; \

21 
	`MAKE_VALUE
(
»suÉ
, 
DT_INT
, -1); \

22 
	`İ
(
Ëá
, 
right
, 
»suÉ
); \

23 
boŞ
 
b
 = 
»suÉ
->
v
.
boŞV
; \

24 
	`ä“
(
»suÉ
); \

25 
	`ASSERT_TRUE
(!
b
,
mes§ge
); \

26 } 0)

	)

29 
‹¡V®ueS”Ÿlize
 ();

30 
‹¡O³¿tÜs
 ();

31 
‹¡Ex´essiÚs
 ();

33 *
	g‹¡Name
;

37 
	$maš
 ()

39 
‹¡Name
 = "";

41 
	`‹¡V®ueS”Ÿlize
();

42 
	`‹¡O³¿tÜs
();

43 
	`‹¡Ex´essiÚs
();

46 
	}
}

50 
	$‹¡V®ueS”Ÿlize
 ()

52 
‹¡Name
 = "test value serialization‡nd deserialization";

54 
	`ASSERT_EQUALS_STRING
(
	`£rŸlizeV®ue
(
	`¡ršgToV®ue
("i10")), "10", "create Value 10");

55 
	`ASSERT_EQUALS_STRING
(
	`£rŸlizeV®ue
(
	`¡ršgToV®ue
("f5.3")), "5.300000", "create Value 5.3");

56 
	`ASSERT_EQUALS_STRING
(
	`£rŸlizeV®ue
(
	`¡ršgToV®ue
("sHello World")), "Hello World", "create Value Hello World");

57 
	`ASSERT_EQUALS_STRING
(
	`£rŸlizeV®ue
(
	`¡ršgToV®ue
("bt")), "true", "create Valuerue");

58 
	`ASSERT_EQUALS_STRING
(
	`£rŸlizeV®ue
(
	`¡ršgToV®ue
("btrue")), "true", "create Valuerue");

60 
	`TEST_DONE
();

61 
	}
}

65 
	$‹¡O³¿tÜs
 ()

67 
V®ue
 *
»suÉ
;

68 
‹¡Name
 = "test value comparison‡nd boolean operators";

69 
	`MAKE_VALUE
(
»suÉ
, 
DT_INT
, 0);

72 
	`OP_TRUE
(
	`¡ršgToV®ue
("i10"),¡ršgToV®ue("i10"), 
v®ueEqu®s
, "10 = 10");

73 
	`OP_FALSE
(
	`¡ršgToV®ue
("i9"),¡ršgToV®ue("i10"), 
v®ueEqu®s
, "9 != 10");

74 
	`OP_TRUE
(
	`¡ršgToV®ue
("sH–lØWÜld"),¡ršgToV®ue("sH–lØWÜld"), 
v®ueEqu®s
, "Hello World = Hello World");

75 
	`OP_FALSE
(
	`¡ršgToV®ue
("sH–lØWÜl"),¡ršgToV®ue("sH–lØWÜld"), 
v®ueEqu®s
, "Hello Worl != Hello World");

76 
	`OP_FALSE
(
	`¡ršgToV®ue
("sH–lØWÜl"),¡ršgToV®ue("sH–lØWÜ"), 
v®ueEqu®s
, "Hello Worl != Hello Wor");

79 
	`OP_TRUE
(
	`¡ršgToV®ue
("i3"),¡ršgToV®ue("i10"), 
v®ueSm®Ër
, "3 < 10");

80 
	`OP_TRUE
(
	`¡ršgToV®ue
("f5.0"),¡ršgToV®ue("f6.5"), 
v®ueSm®Ër
, "5.0 < 6.5");

83 
	`OP_TRUE
(
	`¡ršgToV®ue
("bt"),¡ršgToV®ue("bt"), 
boŞAnd
, "t AND =");

84 
	`OP_FALSE
(
	`¡ršgToV®ue
("bt"),¡ršgToV®ue("bf"), 
boŞAnd
, "t AND f = f");

86 
	`OP_TRUE
(
	`¡ršgToV®ue
("bt"),¡ršgToV®ue("bf"), 
boŞOr
, "t OR f =");

87 
	`OP_FALSE
(
	`¡ršgToV®ue
("bf"),¡ršgToV®ue("bf"), 
boŞOr
, "f OR f = f");

89 
	`TEST_CHECK
(
	`boŞNÙ
(
	`¡ršgToV®ue
("bf"), 
»suÉ
));

90 
	`ASSERT_TRUE
(
»suÉ
->
v
.
boŞV
, "!f =");

92 
	`TEST_DONE
();

93 
	}
}

97 
	$‹¡Ex´essiÚs
 ()

99 
Ex´
 *
İ
, *
l
, *
r
;

100 
V®ue
 *
»s
;

101 
‹¡Name
 = "test complexƒxpressions";

103 
	`MAKE_CONS
(
l
, 
	`¡ršgToV®ue
("i10"));

104 
	`ev®Ex´
(
NULL
, NULL, 
l
, &
»s
);

105 
	`OP_TRUE
(
	`¡ršgToV®ue
("i10"), 
»s
, 
v®ueEqu®s
, "Const 10");

107 
	`MAKE_CONS
(
r
, 
	`¡ršgToV®ue
("i20"));

108 
	`ev®Ex´
(
NULL
, NULL, 
r
, &
»s
);

109 
	`OP_TRUE
(
	`¡ršgToV®ue
("i20"), 
»s
, 
v®ueEqu®s
, "Const 20");

111 
	`MAKE_BINOP_EXPR
(
İ
, 
l
, 
r
, 
OP_COMP_SMALLER
);

112 
	`ev®Ex´
(
NULL
, NULL, 
İ
, &
»s
);

113 
	`OP_TRUE
(
	`¡ršgToV®ue
("bt"), 
»s
, 
v®ueEqu®s
, "Const 10 < Const 20");

115 
	`MAKE_CONS
(
l
, 
	`¡ršgToV®ue
("bt"));

116 
	`ev®Ex´
(
NULL
, NULL, 
l
, &
»s
);

117 
	`OP_TRUE
(
	`¡ršgToV®ue
("bt"), 
»s
, 
v®ueEqu®s
, "Construe");

119 
r
 = 
İ
;

120 
	`MAKE_BINOP_EXPR
(
İ
, 
r
, 
l
, 
OP_BOOL_AND
);

121 
	`ev®Ex´
(
NULL
, NULL, 
İ
, &
»s
);

122 
	`OP_TRUE
(
	`¡ršgToV®ue
("bt"), 
»s
, 
v®ueEqu®s
, "(Const 10 < Const 20) ANDrue");

124 
	`TEST_DONE
();

125 
	}
}

	@test_helper.h

1 #iâdeà
TEST_HELPER_H


2 
	#TEST_HELPER_H


	)

4 
	~<¡dio.h
>

5 
	~<¡dlib.h
>

6 
	~<¡ršg.h
>

7 
	~<time.h
>

10 *
‹¡Name
;

13 
	#TEST_INFO
 
__FILE__
, 
‹¡Name
, 
__LINE__
, 
__TIME__


	)

16 
	#TEST_CHECK
(
code
) \

18 
rc_š‹º®
 = (
code
); \

19 ià(
rc_š‹º®
 !ğ
RC_OK
) \

21 *
mes§ge
 = 
	`”rÜMes§ge
(
rc_š‹º®
); \

22 
	`´štf
("[%s-%s-L%i-%s] FAILED: O³¿tiÚ„‘uºedƒ¼Ü: %s\n",
TEST_INFO
, 
mes§ge
); \

23 
	`ä“
(
mes§ge
); \

24 
	`ex™
(1); \

26 } 0);

	)

29 
	#ASSERT_EQUALS_STRING
(
ex³ùed
,
»®
,
mes§ge
) \

31 ià(
	`¡rcmp
((
ex³ùed
),(
»®
)) != 0) \

33 
	`´štf
("[%s-%s-L%i-%s] FAILED:ƒx³ùed <%s> buˆwa <%s>: %s\n",
TEST_INFO
, 
ex³ùed
, 
»®
, 
mes§ge
); \

34 
	`ex™
(1); \

36 
	`´štf
("[%s-%s-L%i-%s] OK:ƒx³ùed <%s>‡nd wa <%s>: %s\n",
TEST_INFO
, 
ex³ùed
, 
»®
, 
mes§ge
); \

37 } 0)

	)

40 
	#ASSERT_EQUALS_INT
(
ex³ùed
,
»®
,
mes§ge
) \

42 ià((
ex³ùed
è!ğ(
»®
)) \

44 
	`´štf
("[%s-%s-L%i-%s] FAILED:ƒx³ùed <%i> buˆwa <%i>: %s\n",
TEST_INFO
, 
ex³ùed
, 
»®
, 
mes§ge
); \

45 
	`ex™
(1); \

47 
	`´štf
("[%s-%s-L%i-%s] OK:ƒx³ùed <%i>‡nd wa <%i>: %s\n",
TEST_INFO
, 
ex³ùed
, 
»®
, 
mes§ge
); \

48 } 0)

	)

51 
	#ASSERT_TRUE
(
»®
,
mes§ge
) \

53 ià(!(
»®
)) \

55 
	`´štf
("[%s-%s-L%i-%s] FAILED:ƒx³ùedrue: %s\n",
TEST_INFO
, 
mes§ge
); \

56 
	`ex™
(1); \

58 
	`´štf
("[%s-%s-L%i-%s] OK:ƒx³ùedrue: %s\n",
TEST_INFO
, 
mes§ge
); \

59 } 0)

	)

63 
	#ASSERT_ERROR
(
ex³ùed
,
mes§ge
) \

65 
»suÉ
 = (
ex³ùed
); \

66 ià(
»suÉ
 =ğ(
RC_OK
)) \

68 
	`´štf
("[%s-%s-L%i-%s] FAILED:ƒx³ùed‡À”rÜ: %s\n",
TEST_INFO
, 
mes§ge
); \

69 
	`ex™
(1); \

71 
	`´štf
("[%s-%s-L%i-%s] OK:ƒx³ùed‡À”rÜ‡nd wa RC <%i>: %s\n",
TEST_INFO
, 
»suÉ
 , 
mes§ge
); \

72 } 0)

	)

75 
	#TEST_DONE
() \

77 
	`´štf
("[%s-%s-L%i-%s] OK: fšishede¡\n\n",
TEST_INFO
); \

78 } 0)

	)

	@
1
.
0
15
183
buffer_mgr.h
buffer_mgr_stat.c
buffer_mgr_stat.h
dberror.c
dberror.h
dt.h
expr.c
expr.h
record_mgr.h
rm_serializer.c
storage_mgr.h
tables.h
test_assign3_1.c
test_expr.c
test_helper.h
